package uk.ac.nottingham.ningboport.planner;

import java.util.Calendar;
import java.util.Collections;
import java.util.Vector;

import uk.ac.nottingham.ningboport.planner.algorithms.Insertion;
import uk.ac.nottingham.ningboport.planner.algorithms.VNS;

public class EventBasedSimulator {
	private Vector<CommodityEvent> commodityEvents;
	private Calendar currentTime;
	private Network nw;
	
	//TODO: if it is simulated. we no longer need to specify number of shifts
	EventBasedSimulator(Vector<CommodityEvent> events, Network nw) {
		commodityEvents = events;
		System.out.printf("There are %d events parsed from %d commodities\n",
				events.size(), nw.commodities.size());
		this.nw = nw;
	}
	
	public void run() {
		Collections.sort(commodityEvents);
		currentTime = commodityEvents.firstElement().eventTime;
		
		int commodityEventSize = commodityEvents.size();
		for (int i = 0; i < commodityEventSize; i++) {
			//reveal commodities in event
			CommodityEvent event = commodityEvents.get(i);
			int commoditySize = event.commodities.size();
			System.out.printf("There are %d commodities revealed\n", commoditySize);
			for (int j = 0; j < commoditySize; j++) {
				event.commodities.get(j).revealed = true;
			}
			
			// set current time and make all tasks
			// before/in current time finished/finishing
			currentTime = event.eventTime;
			setFinishedTask(currentTime);
			removeUnfinishedTask();
			// run the algorithm
//			Insertion ins = new Insertion(nw, false, false);
//			ins.run();
			//TODO: test if T12120620 is completed after vns
//			VNS ts = new VNS(nw);
//			ts.run();
			
		}
	}
	
	/*
	 * Given a time value, set all finished TA (and ta that is being finished)
	 * as finished = true
	 */
	private void setFinishedTask(Calendar ctime) {
		if (!nw.checkAllRoutes()) {
			RoutingPlanner.errormsg("Error setting finished ta: not all routes currect!");
			System.exit(0);
		}
		
		int numberOfShifts = nw.getNumberOfShifts();
		for (int i = 0; i < numberOfShifts; i++) {
			int nroutes = nw.routesOfShifts.get(i).size();
			for (int j = 0; j < nroutes; j++) {
				Vector<Task> taskSet = nw.routesOfShifts.get(i).get(j).taskSet;
				int tsSize = taskSet.size();
				for (int k = 0; k < tsSize; k++) {
					Task t = taskSet.get(k);
					if (ctime.after(t.startT)) {
						t.actualStartT = (Calendar) t.startT.clone();
						if (ctime.after(t.finishT)) {
							t.actualFinishT = (Calendar) t.finishT.clone();
						}
					}

				}// task set loop				
			}
		}
	}
	
	private void removeUnfinishedTask() {
		for (int shiftI = 0; shiftI < nw.getNumberOfShifts(); shiftI++) {
			Vector<Route> currentPeriod = nw.routesOfShifts.get(shiftI);
			int rsize = currentPeriod.size();
			for (int i = 0; i < rsize; i++) {
				Vector<Task> taskSet = currentPeriod.elementAt(i).taskSet;
				for (int j = 0; j < taskSet.size(); j++) {
					Task t = taskSet.get(j);
					if (!t.freezed()) {
						nw.taskSet.add(taskSet.remove(j--));
					}
				}
			}
		}
	}
	
}
